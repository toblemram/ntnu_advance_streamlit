import math
import pandas as pd
import numpy as np

# ---------------------------------------------------------
# ORIENTATION CALCULATION
# ---------------------------------------------------------
def orientation(tunnel_dir, strike, dip):
    return abs(
        math.degrees(
            math.asin(math.sin(math.radians(tunnel_dir - strike)) * math.sin(math.radians(dip)))
        )
    )

# ---------------------------------------------------------
# KS TABLES FROM RAWDATA
# ---------------------------------------------------------
KS_TABLE = {
    "Sf1": {
        "alpha": [0.000, 4.175, 10.052, 16.005, 19.871, 29.923, 39.974,
                  50.026, 59.768, 69.897, 80.026, 90.000],
        "Ks":    [0.376, 0.382, 0.388, 0.396, 0.401, 0.411, 0.419,
                  0.421, 0.421, 0.417, 0.403, 0.386]
    },
    "Sf2": {
        "alpha": [0.000, 10.052, 20.026, 30.077, 39.974, 43.995, 50.026,
                  55.052, 60.077, 66.031, 71.985, 79.871, 85.902, 90.000],
        "Ks":    [0.390, 0.429, 0.464, 0.497, 0.520, 0.526, 0.532,
                  0.534, 0.532, 0.522, 0.507, 0.474, 0.442, 0.415]
    },
    "Sf3": {
        "alpha": [0.000, 10.129, 19.948, 30.077, 40.052, 44.923, 50.026,
                  55.747, 59.923, 65.103, 69.974, 74.845, 79.948, 85.438, 90.000],
        "Ks":    [0.405, 0.476, 0.550, 0.622, 0.678, 0.700, 0.713,
                  0.721, 0.719, 0.705, 0.680, 0.645, 0.592, 0.522, 0.446]
    },
    "Sf4": {
        "alpha": [0.000, 10.052, 20.026, 30.000, 40.052, 45.000, 49.948,
                  53.969, 57.990, 60.000, 63.943, 67.964, 71.985, 76.160,
                  79.871, 85.129, 90.000],
        "Ks":    [0.433, 0.565, 0.704, 0.836, 0.961, 1.011, 1.050,
                  1.070, 1.080, 1.076, 1.056, 1.017, 0.959, 0.879,
                  0.795, 0.655, 0.499]
    },
    "Sf5": {
        "alpha": [0.000, 9.974, 20.026, 30.000, 39.974, 46.005, 49.948,
                  53.892, 57.912, 63.943, 69.974, 79.948, 90.000],
        "Ks":    [0.729, 0.889, 1.054, 1.220, 1.378, 1.454, 1.491,
                  1.514, 1.516, 1.477, 1.393, 1.175, 0.896]
    }
}

def interpolate_ks(fr_class, alpha):
    if fr_class == "Sr0":
        return 0.36
    df = KS_TABLE.get(fr_class)
    if df is None:
        return 0.36
    return float(np.interp(alpha, df["alpha"], df["Ks"]))

# ---------------------------------------------------------
# TOTAL FRACTURING FACTOR
# ---------------------------------------------------------
def total_fracturing_factor(k1, k2, k3, fr1, fr2, fr3):
    fr = [fr1, fr2, fr3]
    ks = [k1, k2, k3]
    total_ks = sum(ks)
    num_active = 3 - fr.count("Sr0")
    penalty = (num_active - 1) * 0.36 if num_active > 1 else 0
    return total_ks - penalty

def rock_mass_fracturing_factor(ks_tot):
    return min(ks_tot, 3.5)

# ---------------------------------------------------------
# POROSITY TABLE
# ---------------------------------------------------------
POROSITY_TABLE = pd.DataFrame({
    "Por":  [0, 2, 3.038, 4.000, 4.952, 6.010, 7.058, 8.000, 9.048, 10.000, 11.067, 12.000],
    "Kpor": [1, 1, 1.215, 1.432, 1.669, 1.957, 2.263, 2.558, 2.909, 3.242, 3.632, 3.996]
})

def k_porosity(por):
    return float(np.interp(por, POROSITY_TABLE["Por"], POROSITY_TABLE["Kpor"]))

# ---------------------------------------------------------
# KDri Table â€” FULL TABLE
# ---------------------------------------------------------
KDRI_TABLE = pd.DataFrame([
    [0.36,20.00,0.43],[0.36,22.22,0.48],[0.36,26.06,0.56],[0.36,27.83,0.60],
    [0.36,29.72,0.64],[0.36,31.54,0.68],[0.36,33.56,0.71],[0.36,35.45,0.75],
    [0.36,37.46,0.79],[0.36,39.35,0.82],[0.36,41.12,0.85],[0.36,42.94,0.88],
    [0.36,44.65,0.91],[0.36,46.47,0.94],[0.36,48.17,0.97],[0.36,50.00,1.00],
    [0.36,52.02,1.03],[0.36,54.16,1.06],[0.36,56.17,1.09],[0.36,58.25,1.12],
    [0.36,60.46,1.14],[0.36,62.54,1.17],[0.36,65.06,1.20],[0.36,67.51,1.23],
    [0.36,70.22,1.25],[0.36,72.68,1.28],[0.36,75.07,1.30],[0.36,77.02,1.32],
    [0.36,80.05,1.34],

    [2,20.02,0.75],[2,22.28,0.77],[2,24.36,0.79],[2,26.19,0.81],
    [2,28.58,0.83],[2,30.79,0.85],[2,32.93,0.87],[2,34.76,0.88],
    [2,38.09,0.91],[2,41.18,0.93],[2,42.88,0.95],[2,45.84,0.97],
    [2,47.61,0.98],[2,50.00,1.00],[2,53.28,1.02],[2,55.54,1.04],
    [2,57.81,1.05],[2,60.27,1.06],[2,62.98,1.08],[2,65.43,1.09],
    [2,68.14,1.10],[2,70.47,1.11],[2,73.24,1.13],[2,76.52,1.14],
    [2,80.05,1.15],

    [3.5,20.02,0.91],[3.5,22.72,0.92],[3.5,25.24,0.93],[3.5,28.77,0.94],
    [3.5,31.92,0.95],[3.5,34.82,0.96],[3.5,37.59,0.97],[3.5,40.61,0.98],
    [3.5,43.01,0.98],[3.5,45.02,0.99],[3.5,47.35,0.99],[3.5,50.00,1.00],
    [3.5,52.33,1.00],[3.5,54.54,1.01],[3.5,56.93,1.01],[3.5,59.45,1.02],
    [3.5,62.03,1.02],[3.5,64.93,1.03],[3.5,67.32,1.03],[3.5,69.78,1.04],
    [3.5,72.87,1.04],[3.5,75.26,1.04],[3.5,77.65,1.05],[3.5,80.00,1.05]
], columns=["ks","DRI","k_DRI"])

def k_dri_bilinear(ks, dri, table=KDRI_TABLE):
    unique_ks = sorted(table["ks"].unique(), key=lambda x: abs(x - ks))
    nearest_ks = unique_ks[0]
    sub = table[table["ks"] == nearest_ks].sort_values("DRI")
    return float(np.interp(dri, sub["DRI"], sub["k_DRI"]))

# ---------------------------------------------------------
# Critical cutter thrust (lookup table)
# ---------------------------------------------------------
M1_TABLE = [
    (0.2,241.875),(0.252,225.375),(0.294,212.25),(0.3332,201),
    (0.4004,183.75),(0.476,166.5),(0.5516,151.125),(0.6272,136.875),
    (0.7308,122.25),(0.8148,111),(0.9212,100.125),(1.0276,90),
    (1.1452,81.75),(1.2852,73.875),(1.4168,67.875),(1.5988,61.5),
    (1.7752,57),(1.9124,54.375),(2.0608,51.75),(2.2204,48.375),
    (2.3632,46.5),(2.5088,44.625),(2.6852,42.75),(2.8728,41.25),
    (3.0156,40.125),(3.1556,39.375),(3.3012,39),(3.4104,38.625),(3.5,38.25)
]

m1_k = np.array([r[0] for r in M1_TABLE])
m1_v = np.array([r[1] for r in M1_TABLE])

def critical_cutter_thrust(k_equiv):
    return float(np.interp(k_equiv, m1_k, m1_v))

# ---------------------------------------------------------
# Penetration coefficient (lookup table)
# ---------------------------------------------------------
B_TABLE = [
    (0.2,4.057471),(0.241573,3.798851),(0.27809,3.563218),
    (0.320225,3.33908),(0.370787,3.132184),(0.446629,2.885057),
    (0.542135,2.637931),(0.629213,2.471264),(0.724719,2.304598),
    (0.842697,2.126437),(0.977528,1.965517),(1.176966,1.787356),
    (1.356742,1.672414),(1.52809,1.603448),(1.693832,1.551724),
    (1.86236,1.522989),(2.058989,1.477011),(2.261236,1.442529),
    (2.452247,1.413793),(2.646067,1.390805),(2.823034,1.37931),
    (3.134831,1.362069),(3.351124,1.356322),(3.5,1.350575)
]

b_k = np.array([r[0] for r in B_TABLE])
b_v = np.array([r[1] for r in B_TABLE])

def penetration_coefficient(k_equiv):
    return float(np.interp(k_equiv, b_k, b_v))
